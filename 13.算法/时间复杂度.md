##常用的算法的时间复杂度和空间复杂度：

| 排序法     | 最差时间分析 | 平均时间复杂度 | 稳定度 |    空间复杂度 |
|------------|:------------:|:--------------:|:------:|--------------:|
| 冒泡排序   |    O(n2)     |     O(n2)      |  稳定  |          O(1) |
| 快速排序   |    O(n2)     |   O(n*log2n)   | 不稳定 | O(log2n)~O(n) |
| 选择排序   |    O(n2)     |     O(n2)      |  稳定  |          O(1) |
| 二叉树排序 |    O(n2)     |   O(n*log2n)   | 不一顶 |          O(n) |
| 插入排序   |    O(n2)     |     O(n2)      |  稳定  |          O(1) |
| 堆排序     |  O(n*log2n)  |   O(n*log2n)   | 不稳定 |          O(1) |
| 希尔排序   |      O       |       O        | 不稳定 |          O(1) |



##常见的时间复杂度：

| 执行次数函数  |        阶        | 术语描述 |
|---------------|:----------------:|---------:|
| 12	O(1)        |      常数阶      |          |
| 2n+3          |    O(n)	线性阶    |          |
| 3n2+2n+1      |   O(n2)	平方阶    |          |
| 5log2n+20     |  O(log2n)	对数阶  |          |
| 2n+3nlog2n+19 | O(nlogn)	nlog2n阶 |          |
| 6n3+2n2+3n+4  |   O(n3)	立方阶    |          |
| 2n O(2n)      |      指数阶      |          |

***
```
时间复杂度所耗费的时间是：
O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) <O(2n) < O(n!) <O(nn)
```

在描述算法复杂度时,经常用到o(1), o(n), o(logn), o(nlogn)来表示对应算法的时间复杂度, 这里进行归纳一下它们代表的含义: 
这是算法的时空复杂度的表示。不仅仅用于表示时间复杂度，也用于表示空间复杂度。 
O后面的括号中有一个函数，指明某个算法的耗时/耗空间与数据增长量之间的关系。其中的n代表输入数据的量。 
1. 时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。
再比如时间复杂度O(n^2)，就代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。 
再比如O(logn)，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。 
O(nlogn)同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序（快速排序也是）就是O(nlogn)的时间复杂度。 
O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）冲突的话很麻烦的，指向的value会做二次hash到另外一快存储区域

总之，
在平均情况下，快速排序最快；
在最好情况下，插入排序和起泡排序最快；
在最坏情况下，堆排序和归并排序最快。