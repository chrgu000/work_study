### 分布式锁


> 概念

分布式锁，是指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。

> 分布式锁要满足哪些要求呢？

- 排他性：在同一时间只会有一个客户端能获取到锁，其它客户端无法同时获取
- 避免死锁：这把锁在一段有限的时间之后，一定会被释放（正常释放或异常释放）
- 高可用：获取或释放锁的机制必须高可用且性能佳

> 分布式锁的实现方式有哪些？

- 基于数据库实现
- 基于Redis实现
- 基于ZooKeeper实现


###  基于数据库来做分布式锁的话，通常有两种做法：

>> 基于数据库的乐观锁

- 乐观锁机制其实就是在数据库表中引入一个版本号（version）字段来实现的。
- 每次更新数据的时候都必须先判断版本号对不对，然后再写入新的版本号

>> 基于数据库的悲观锁(事务里 for update)

- 悲观锁也叫作排它锁，在Mysql中是基于 for update 来实现加锁的
- user表中，id是主键，通过 for update 操作，数据库在查询的时候就会给这条记录加上排它锁。
- （需要注意的是，在InnoDB中只有字段加了索引的，才会是行级锁，否者是表级锁，所以这个id字段要加索引）
- 当这条记录加上排它锁之后，其它线程是无法操作这条记录的。
- 那么，这样的话，我们就可以认为获得了排它锁的这个线程是拥有了分布式锁，然后就可以执行我们想要做的业务逻辑，当逻辑完成之后，再调用上述释放锁的语句即可

### 基于Redis实现

基于Redis实现的锁机制，主要是依赖redis自身的原子操作 SETNX

NX：只在在键不存在时，才对键进行设置操作，SET key value NX 效果等同于 SETNX key value

因为这个命令是只有在某个key不存在的时候，才会执行成功。那么当多个进程同时并发的去设置同一个key的时候，就永远只会有一个进程成功。

解锁很简单，只需要删除这个key就可以了，不过删除之前需要判断，这个key对应的value是当初自己设置的那个。

>> 另外，针对redis集群模式的分布式锁，可以采用redis的Redlock机制。

### 基于ZooKeeper实现
> 概念

ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等

> 原理

其实基于ZooKeeper，就是使用它的临时有序节点来实现的分布式锁

原理就是：当某客户端要进行逻辑的加锁时，就在zookeeper上的某个指定节点的目录下，去生成一个唯一的临时有序节点， 然后判断自己是否是这些有序节点中序号最小的一个，如果是，则算是获取了锁。如果不是，则说明没有获取到锁，那么就需要在序列中找到比自己小的那个节点，并对其调用exist()方法，对其注册事件监听，当监听到这个节点被删除了，那就再去判断一次自己当初创建的节点是否变成了序列中最小的。如果是，则获取锁，如果不是，则重复上述步骤。

当释放锁的时候，只需将这个临时节点删除即可。

## 每种方案的相关问题
数据库

- 这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用
- 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。
- 还有一个问题，就是我们要使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆

redis

- 使用缓存实现分布式锁的优点
- 性能好，实现起来较为方便。
- 使用缓存实现分布式锁的缺点
- 通过超时时间来控制锁的失效时间并不是十分的靠谱。
- 

Zookeeper

- 有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。
- 使用Zookeeper实现分布式锁的缺点
- 性能上不如使用缓存实现分布式锁。 需要对ZK的原理有所了解。