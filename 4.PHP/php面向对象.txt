-----------------------------------------------
面向对象的介绍
-----------------------------------------------
面向对象程序设计OOP是一种计算机的编程架构，OOP的一条基本原则是：计算机程序是由单个能起到子程序作用的单元或对象组合而成的，为了实现整体运算，每个对象都能够接收消息，处理数据和像其他对象发送信息，OOP达到了软件工程的3个目标：重用性，灵活性，扩展性，使其编程的代码更简洁，更易于维护，并且具有更强的可重用性。
类与对象关系就是模具和零件的关系，类的实例化结果就是对象，而对象的抽象就是类，类描述了一组相同特性（属性）和相同行为（方法）的对象
----------------------
7.2.1 类的申明
----------------------
{一些修饰类的关键字}class 类名{
               成员属性：姓名，性别，年龄，身高，体重
               成员方法：说话，学习，走路，吃饭，开车
}
解释：静态描述就是我们所说的属性，在程序中可以用变量实现，例如 人的姓名，性别
      动态描述就是对象的功能，就是人可以开车，会说英语，可以使用计算机
      创建类只需要使用一个关键字class 后面加上一个自定义的类别名称，后面一个花括号，有时候也需要在class关键字的前面加上一下修饰类的关键字 如 abstract 和final 
----------------------
7.2.2 成员属性
----------------------
class Person {
    public $name;    //第一个成员属性声明为公有的权限
    private $age;    //第二个成员属性声明为私有的权限
    static $sex;     //第三个成员属性声明为静态的权限
}
----------------------
7.2.3 成员方法
----------------------
class Person {
    function say() {              //声明一个成员方法，定义人说话的功能
        //方法体
    }
    function eat($food) {         //声明一个成员方法，定义人可以吃饭的功能，使用一个参数（吃什么食物）
        //方法体
    }
    private function run() {      //定义人走路的功能，使用private修饰访问权限
        //方法体
    }
}
-----------------------------------------------
7.2总结：
-----------------------------------------------
对象就是把相关属性和方法组织在一起形成一个集合，其类中成员属性和成员方法都是可选的，也可以都具有成员属性和成员方法
----------------------
7.3.1实例化对象
----------------------
使用new关键字
例如 $pre=new Person();获取  $pre=new Person($cc); 可以在类中传递参数
同一个类可以实例化多个对象
$pre1=new Person();
$pre2=new Person();
$pre3=new Person();
实例化出来的三个对象$pre1，$pre2，$pre3 相当于在内存中开辟了三份空间用于存放每个对象，使用同一个人声明的多个对象之间是没有联系的
----------------------
7.3.2 对象中成员的访问
----------------------
对成员属性的方法包括赋值操作和获取成员属性值的操作，只能通过对象的引用来访问对象的每个成员，使用一个特殊的运算符号 ->
$pre1=new Person();
$pre1->name='名称';   //将对象$pre1中的$name赋值为名称
$pre1->name;          //访问对象$pre1中的成员属性$name
$pre1->say();
$pre1是对象引用名  
只要是对象中的成员，都需要使用 对象引用名->属性  对象引用名->方法 形式来访问，如果对象中的成员不是静态的，那么这是唯一的访问形式
----------------------
7.3.3 特殊的对象引用 $this   -->在类的内部使用成员属性，代表‘本对象’的一个引用，但只能在对象的成员方法中使用 ，还得使用一个特殊的运算符号 ->
----------------------
class Person {
    var $name;
    function say() {              //声明一个成员方法，定义人说话的功能
        //方法体
    }
    function eat($food) {         //声明一个成员方法，定义人可以吃饭的功能，使用一个参数（吃什么食物）
        //方法体
    }
    function run() {      //定义人走路的功能，使用private修饰访问权限
        echo $this->name . "在走路";
    }
}

$pre = new Person();
$pre->name = '李四';
$pre->run();
结果是李四在走路
----------------------
7.3.4 构造方法和析构方法
----------------------
在类中声明构造方法的格式如下--》new Person(‘参数’); 带有参数首先执行__construct()方法，只传入一个参数，其他2个参数使用默认参数
function __construct(){
    //方法体。通常用来对成员属性进行初始化赋值
}

析构方法申明--》析构方法不能带有任何参数，如果在析构方法中输出一条语句，由于栈的后进先出的特点，最后创建的对象会被最先释放，
function __destruct(){
    //方法体。通常用来完成一些在对象销毁前的清理任务
}
$pre1=new Person();
$pre1=null;
$pre2=new Person();
$pre3=new Person();
首先释放$pre1 其次$pre3 最后$pre2
-----------------------------------------------
7.4 封装性
-----------------------------------------------
----------------------
7.4.1 设置私有成员
----------------------
使用private关键字修饰就实现了对成员的封装，封装后的成员在对象的外部不能被访问，如果写出这样的代码就会报错，就不可以在对象的外部用个对象的引用直接访问了，
----------------------
7.4.2 私有成员的访问
----------------------
解决的方法就是在对象的内部声明一些操作私有属性的公有方法，因为私有的成员属性在对象内部的方法可以访问，
总结：构造方法就是一种为私有属性赋值的形式，但是构造方法只能在创建对象时为私有属性赋初值，如果我们已经创建一个对象，在程序中对它的私有属性重新赋值，可以在公有的方法中增加一些限制条件，避免一些非法的操作，这样就能达到封装的目的，所有的功能都是对象的自己来完成，给外面提供尽量少的操作
----------------------
7.4.3 __set()和__get()方法 魔术方法
----------------------
使用时不需要用户直接调用，而是在特定的情况下自动被调用
__set() 2个参数，在实例化对象后，给私有属性赋值，（或者不存在的值）自动调用 里面可以先一定的判断条件，满足条件在进行赋值 
__get() 1个参数，在实例化对象后，获取私有属性的值（或者不存在的值）自动调用
-----------------------------------------------
7.5继承性--》就是通过子类对已经存在的父类进行功能扩展
-----------------------------------------------
----------------------
7.5.2 访问类型控制
----------------------
private 只能在类本身访问，
protected 本类，和子类可以使用， 
public全部可用
----------------------
7.5.3 子类中重载父类的方法
----------------------
一种方式是，在子类中新建一个和父类中方法名称一样的方法，具体的业务逻辑自己在写，
另一种方式是，有前提条件，就是父类的方法和业务逻辑全部要，在加上一些新的逻辑，可以使用创建say方法 使用parent::say()  在加上一些业务逻辑。这种方法需要注意：在子类中重写方法的访问权限一定不能低于父类被覆盖的方法的访问权限，方法重载需要
-----------------------------------------------
7.6常见的关键字和魔术方法
-----------------------------------------------
----------------------
7.6.1 final 关键字的应用
----------------------
（1）使用final标识的类，不能被继承
（2）使用final标识的方法，不能被重载
 不满足这条件都会 fatal error
----------------------
7.6.2 static 关键字的使用
----------------------
使用static关键字可以将类中的成员标识为静态的，既可以表示成员属性，也可以标识成员方法
如果是普通成员属性，则不管通过类实例化多少个对象，每个对象都有自己的属性，互补干扰，，如果加上static则这个static成员都是唯一存在的，在多个对象直接共享，类的静态属性类似函数的全部变量
类的静态成员是不需要对象而使用类名直接访问的,可以使用对象引用和使用类名来访问静态成员
在类的外部和成员方法中--静态方法又不能访问非静态的 成员
类名::静态成员属性名
类名::静态成员方法名()
在本类的成员方法中
self::静态成员属性名
self::静态成员方法名()
class Myclass {
    static $count;
    function __construct() {
        //$count=$count+1;    //这种报错notice 因为静态属性不允许这样方法     
        self::$count=self::$count+2;//这种结果为66
        self::$count++; //这种结果为33
    }
    static function getcount() {
        return self::$count;
    }
}
Myclass::$count = 0; //在类外面使用类名访问静态成员，为其初始化赋值0
$my1 = new Myclass();//通过创建对象，在构造方法中对count加1，
$my2 = new Myclass();//通过创建对象，在构造方法中对count加1，
$my3 = new Myclass();//通过创建对象，在构造方法中对count加1，全局共享 值变为3
echo Myclass::getcount(); //通过2种方式访问静态成员方法，结果都是self::$count 值不变
echo $my3->getcount();
----------------------
7.6.3 const 关键字
----------------------
在php中定义常量是通过调用define()函数完成，在类中定义常量使用const关键字，
在类的外部和成员方法中
类名::常量名
在本类的成员方法中
self::常量名
注意：不能使用对象名来访问，这点和static不同
----------------------
7.6.4 clone 关键字
----------------------
克隆对象，相当于多次new 关键字来创建对象（这样比较繁琐，也容易出错） 
$p1=new Person();
$p2= clone p1;
$p2 $p12个对象完全独立，互补干扰
__clone() 该方法是克隆的时候自动调用，新的对象优先使用这个克隆方法，赋值也使用克隆对象里面的值
----------------------
7.6.5 __toString()
----------------------
 本来直接输出实例化的对象会出错 Catchable fatal error 如果加上__toString() 则输出对象执行这个方法返回的结果，注意：这个函数必须有返回值，而且还是成员属性和成员方法的值，需要传送参数的值，不然还是会报错
----------------------
7.6.6 __call()
----------------------
2个参数，函数方法名，方法相关参数  如果尝试调用对象中不存在的方法，一定会出现系统报错 ，如果方法不存在，就自动调用这个方法
----------------------
7.6.6 __autoload()
----------------------
实现自动加载类，实例化不存在的类，调用__autoload()将类名user 作为参数传入，在这个函数__autoload() include导入文件
----------------------
instanceof 关键字
----------------------
 -使用这个关键字可以确定一个对象是类的实例，类的子类，还是实现接口
$man=new Person();
if($man instanceof Person){
成功
}
----------------------
魔术方法
----------------------
__isset() 在对象的外部使用 isset方法测定对象中的成员时，会自动调用__isset()，有这个方法，私有属性才可以检测，返回布尔值
__unset() 在对象的外部使用 unset方法直接删除对象中的成员属性，会自动调用__unset() 如果对象没有这个函数，只能删除公有的成员属性，有这个方法，加入一定限制条件，阻止删除一些重要的属性
__sleep() 在调用serialize（）函数将对象串行化时，会自动调用对象的__sleep() ,不带有参数，返回一个数组，在数组中包含需要串行的属性，如果没有这个方法，则对象的所有属性都将串行
__wakeup()在调用unserialize（）函数将对象反串行化时，会自动调用对象的__wakeup()，在该方法中可以为反串行化对象中的$age成员属性重新赋值
-----------------------------------------------
10.7抽象类与接口
-----------------------------------------------
-抽象类和接口相似，都是一种比较特殊的类，，接口是一种特殊的抽象类，配合多态一起使用
----------------------
10.7.1抽象类
----------------------
只要在声明类时候有一个方法是抽象方法，那么这个类就是抽象类，抽象类也需要abstract关键字修饰，在抽象类中，可以有不是抽象的成员方法和成员属性，但是访问权限不能使用private,
抽象方法不能有花括号，更不能有方法体中的内容，直接在括号后面加上分号结束，还要使用abstract关键字修饰 例如 abstract function func();
抽象类不能实例化，只能被继承，，作为它的子类定义公共接口，将它的操作交给子类去实现，就是将抽象类作为子类重载的模版使用，定义抽象类就是相当于定义了一种规范，要求子类去遵守，子类必须把父类中抽象方法全部实现，否则子类中还有抽象方法，所以还是抽象方法，不能被实例化
声明2个子类都继承抽象类，实现父类-抽象类的方法全部实现，按照每个类不同的需求是实现相同的方法，这样2个子类都可以实例化，抽象类可以看成一个模版，类中的抽象方法自己不去实现，只是规范了子类必须要有父类中声明的抽象方法，而且要按自己类的特点去实现抽象方法的内容
----------------------
10.7.2 接口
----------------------
php只支持单继承，算是解决多继承的一种方法，接口
接口中声明的方法必须都是抽象方法，另外不能在接口中声明变量，只能使用const声明为常量的成员属性，接口的所有成员都是public的访问权限 ，而接口的申明使用 interface 关键字，类是使用class关键字  使用 implements 关键字实现继承，不是使用extends
<?php
interface one{
  const CON='www';
  function fun1();
  function fun2();
}
?>
----------------------
抽象类和接口的区别：
----------------------
1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。
2、抽象类要被子类继承，接口要被类实现。
3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现
4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。
6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果
7、抽象类里可以没有抽象方法（待定）
8、如果一个类里有抽象方法，那么这个类只能是抽象类
9、抽象方法要被实现，所以不能是静态的，也不能是私有的。
10、接口可继承接口，并可多继承接口，但类只能单根继承。
1.抽象类 和 接口 都是用来抽象具体对象的. 但是接口的抽象级别最高
2.抽象类可以有具体的方法 和属性,  接口只能有抽象方法和不可变常量
3.抽象类主要用来抽象类别,接口主要用来抽象功能.
4、抽象类中，且不包含任何实现，派生类必须覆盖它们。接口中所有方法都必须是未实现的。
魔术方法
__set() __get() __isset()  __unset()  __construct() __destruct()  __clone()  __toString() __call() __autoload()
类的属性序列化，恢复这个类，使用函数
unserialize
